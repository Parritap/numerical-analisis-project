
\subsection{Método de Bisección}

El método de bisección, es un algoritmo de búsqueda de raíces que trabaja dividiendo el intervalo a la mitad y seleccionando el subintervalo que tiene la raíz.


Para definir formalmente el método de bisección, usaremos la explicación dada por \cite{Suli2003}: Suponga que $f$ es una función de valor real definida y continua en un intervalo cerrado y acotado $[a, b]$ de la línea real, tal que $f(\xi) = 0$ para algún $\xi \in [a, b]$. El método de bisección es un método iterativo que se construye comenzando con un intervalo $[a_0, b_0]$ que se sabe que contiene la solución $\xi$ (es decir, $f(a_0)$ y $f(b_0)$ tienen signos opuestos) y reduciendo sucesivamente su tamaño a la mitad.

El procedimiento formal es el siguiente:
Para $k \geq 0$, dado un intervalo $(a_k, b_k)$ donde $f(a_k)$ y $f(b_k)$ tienen signos opuestos, se considera el punto medio $c_k$ del intervalo, definido por:
$$c_k = \frac{1}{2} (a_k + b_k)$$

Se evalúa $f(c_k)$.
\begin{itemize}
	\item Si $f(c_k)$ es cero, entonces se ha localizado una solución $\xi$ y la iteración se detiene.
	\item Si $f(c_k)$ no es cero, el nuevo intervalo $(a_{k+1}, b_{k+1})$ se define seleccionando el subintervalo donde $f$ cambia de signo, de la siguiente manera:
	      $$(a_{k+1}, b_{k+1}) = \begin{cases} (a_k, c_k) & \text{si } f(c_k)f(b_k) > 0 \\ (c_k, b_k) & \text{si } f(c_k)f(b_k) < 0 \end{cases}$$
\end{itemize}
Este procedimiento se repite.

\subsubsection{Fundamento teórico}

El método de bisección se fundamenta en el Teorema del Valor Intermedio de Bolzano, uno de los teoremas centrales del análisis matemático que garantiza la existencia de raíces para funciones continuas.

\textbf{Teorema del Valor Intermedio:} Sea $f$ una función continua en el intervalo cerrado $[a, b]$, y sea $N$ cualquier número entre $f(a)$ y $f(b)$ con $f(a) \neq f(b)$. Entonces existe al menos un número $c \in (a, b)$ tal que $f(c) = N$ \citep{Stewart2012_Una}.

Este teorema establece que una función continua toma todos los valores intermedios entre $f(a)$ y $f(b)$ en algún punto del intervalo $(a, b)$ \cite{Stewart2012_Una}.

\textbf{Aplicación al método de bisección:} Para encontrar raíces de una función, se aplica el teorema con $N = 0$. Si una función continua $f$ satisface que $f(a)$ y $f(b)$ tienen signos opuestos, es decir:
\begin{equation}
	f(a) \cdot f(b) < 0
\end{equation}

entonces, por el Teorema del Valor Intermedio, existe al menos un valor $c \in (a, b)$ tal que $f(c) = 0$. Este valor $c$ es precisamente una raíz de la función en el intervalo $(a, b)$.

La condición de signos opuestos es equivalente a que el número cero se encuentre entre $f(a)$ y $f(b)$, garantizando así que la función cruza el eje $x$ al menos una vez dentro del intervalo. Esta propiedad es la base matemática que asegura la convergencia del método de bisección hacia una raíz de la función.

\subsubsection{Algoritmo}

El procedimiento del método de bisección es el siguiente:

\begin{enumerate}
	\item Se elige un intervalo inicial $[a, b]$ tal que $f(a) \cdot f(b) < 0$
	\item Se calcula el punto medio: $c = \frac{a + b}{2}$
	\item Se evalúa $f(c)$:
	      \begin{itemize}
		      \item Si $f(c) = 0$, entonces $c$ es la raíz exacta
		      \item Si $f(a) \cdot f(c) < 0$, la raíz está en $[a, c]$, por lo que $b = c$
		      \item Si $f(c) \cdot f(b) < 0$, la raíz está en $[c, b]$, por lo que $a = c$
	      \end{itemize}
	\item Se repite el proceso hasta que $|b - a| < \epsilon$ o $|f(c)| < \epsilon$, donde $\epsilon$ es la tolerancia deseada.


\end{enumerate}


\subsubsection{Código Matlab}

%\noindent\fbox{\parbox{\dimexpr\textwidth-2\fboxsep-2\fboxrule\relax}{\textbf{Código:} Método de Bisección en MATLAB}}

\begin{lstlisting}
% Script de Biseccion
format short;

try
    funcion = input('Ingrese la funcion para buscar una raiz: f(x) = ', 's');
    f = str2func(['@(x) ' funcion]);
    a = input('Ingrese el valor inicial del intervalo: a = ');
    b = input('Ingrese el valor final del intervalo: b = ');
    errorEsperado = input('Ingrese un error decimal esperado para aproximarse a la raiz: ');

    if f(a) * f(b) > 0
        error('La funcion no corta el eje x en el intervalo dado.');
    else
        % Inicializar arrays para almacenar los valores de cada iteracion
        p_anterior = 0; % Importante para que el primer error sea del 100 por ciento
        iteraciones = [];
        valores_a = [];
        valores_b = [];
        valores_p = [];
        valores_fc = [];
        valores_fa = [];
        cambio_signo = [];
        errores = [];
        error_porcentual = [];

        cont = 0;
        errorActual = inf;

        while errorActual > errorEsperado
            cont = cont + 1;
            p = (a + b) / 2;
            fp = f(p);
            fa = f(a);

            % Calcular error relativo
            if cont == 1
                errorActual = inf; % Primera iteracion siempre continua
            else
                errorActual = abs(p - p_anterior) / abs(p);
            end

            p_anterior = p; % Actualizar para la siguiente iteracion
            signo = (fa * fp) <= 0;
            % Guardar valores de esta iteracion
            iteraciones = [iteraciones; cont];
            valores_a = [valores_a; a];
            valores_b = [valores_b; b];
            valores_p = [valores_p; p];
            valores_fc = [valores_fc; fp];
            valores_fa = [valores_fa; fa];
            cambio_signo = [cambio_signo; signo];
            errores = [errores; errorActual];
            error_porcentual = [error_porcentual; string(errorActual * 100)];

            if fa * fp <= 0
                b = p;
            else
                a = p;
            end

        end

        p = (a + b) / 2;

        % Mostrar tabla de iteraciones
        disp(' ');
        disp('========== TABLA DE ITERACIONES ==========');
        fprintf('\n');
        fprintf('%3s | %10s | %10s | %10s | %10s | %10s | %6s | %10s | %10s\n', ...
            'i', 'a', 'b', 'c', 'f(c)', 'f(a)', 'Signo?', 'Error', 'Error %');
        fprintf('----+-----------+------------+------------+------------+------------+--------+------------+------------\n');

        for k = 1:length(iteraciones)
            fprintf('%3d | %10.4f | %10.4f | %10.4f | %10.4f | %10.4f | %6s | %10.4f | %10.4f\n', ...
                iteraciones(k), valores_a(k), valores_b(k), valores_p(k), ...
                valores_fc(k), valores_fa(k), ...
                char(string(cambio_signo(k))), errores(k), double(error_porcentual(k)));
        end

        fprintf('\n');
        disp('==========================================');
        disp(' ');
        disp('La cantidad de iteraciones fue:');
        disp(['i = ' num2str(cont)]);
        disp('La raiz en la funcion con el error esperado es:');
        disp(['X = ' num2str(p, '%.4f')]);
        disp(['f(X) = ' num2str(f(p), '%.4f')]);
        ezplot(funcion); % Graficamos
        grid on;
    end

catch
    error('Error en la entrada de datos. Asegurese de ingresar la funcion correctamente y valores numericos para los intervalos y el error esperado.');
end
\end{lstlisting}
